<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spellings Practice</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <script src="config.js"></script>
  <!-- Confetti for celebrations -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    :root { --bg: linear-gradient(to bottom right, red, orange, yellow, green, blue, indigo, violet); --text:#333; --section-bg:#fff; }
    body.dark { --bg:#111; --text:#f1f1f1; --section-bg:#222; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--text); }
    header { background:rgba(255,255,255,.85); padding:1rem; text-align:center; font-size:1.5rem; font-weight:800; border-bottom:3px solid #fff; position:relative; z-index:1; }
    .dark header{ background:rgba(0,0,0,.8); border-bottom:3px solid #444; }
    section { background:var(--section-bg); margin:1rem; padding:1rem; border-radius:10px; box-shadow:0 0 10px rgba(0,0,0,.08); }
    h2, h3 { margin:.25rem 0 .5rem; }
    .toggle-mode { position:fixed; bottom:1rem; right:1rem; width:50px; height:50px; background:#000; color:#fff; border:0; border-radius:50%; font-size:24px; cursor:pointer; z-index:999; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 5px rgba(0,0,0,.3);} 
    .toggle-mode.sun{ background:#ffd700; color:#333; }

    /* Prevent card contents from overflowing their boxes */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* Spellings-specific styles */
    .top-bar { display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:.5rem; margin-bottom:.5rem; }
    .back-link {
      font-size:.9rem; text-decoration:none; padding:.35rem .7rem;
      border-radius:999px; border:1px solid #ddd; background:#fafafa; color:inherit;
    }
    .dark .back-link{ background:#111; border-color:#555; }
    .identity-grid { display:flex; flex-wrap:wrap; gap:1rem; }
    .identity-card, .practice-card {
      flex:1 1 260px;
      background:#f9f9f9;
      border-radius:10px;
      padding:.75rem .9rem;
      border:1px solid #eee;
      min-width:0;
    }
    .dark .identity-card, .dark .practice-card{ background:#111; border-color:#333; }
    label { font-size:.85rem; font-weight:600; display:block; margin-bottom:.2rem; }
    input[type="text"], select {
      width:100%; padding:.45rem .6rem; border-radius:6px; border:1px solid #ccc; font:inherit;
    }
    .dark input[type="text"], .dark select{ background:#111; border-color:#555; color:inherit; }
    .mode-options { margin-top:.5rem; }
    .mode-options label { font-weight:500; display:flex; align-items:center; gap:.35rem; margin-bottom:.3rem; cursor:pointer; }
    .note { font-size:.8rem; color:#666; margin-top:.35rem; }

    .start-btn {
      margin-top:.7rem;
      padding:.55rem 1rem;
      border-radius:7px;
      border:0;
      background:#81c784;
      color:#fff;
      font:600 1rem system-ui;
      cursor:pointer;
      transition: background .15s ease;
    }
    .start-btn:hover {
      background:#66bb6a;
    }

    .stats-row { display:flex; flex-wrap:wrap; gap:.5rem; margin-bottom:.5rem; }
    .stat-box { flex:1 1 80px; padding:.4rem .5rem; border-radius:7px; background:#f1f5f9; font-size:.8rem; }
    .dark .stat-box{ background:#020617; }
    .stat-label{ color:#666; font-size:.75rem; }
    .stat-main{ font-weight:700; }

    .mode-tabs { display:flex; gap:.4rem; margin-bottom:.5rem; flex-wrap:wrap; }
    .mode-tab{ border-radius:999px; border:1px solid #ddd; padding:.25rem .7rem; font-size:.8rem; background:#f9fafb; cursor:pointer; }
    .mode-tab.active{ background:#fef3c7; border-color:#fbbf24; }
    .mode-tab.disabled{ opacity:.4; cursor:default; }

    .practice-word { font-size:1.6rem; font-weight:800; text-align:center; letter-spacing:.15em; margin:.5rem 0 .6rem; }

    .answer-row{ display:flex; flex-wrap:wrap; gap:.4rem; justify-content:center; margin-bottom:.25rem; }
    .answer-row input[type="text"]{ max-width:220px; }

    .primary-btn{ padding:.45rem .9rem; border-radius:7px; border:0; background:#f97316; color:#fff; font-weight:700; cursor:pointer; }

    .secondary-btn{
      margin:0 auto .4rem auto;
      display:block;
      padding:.3rem .7rem;
      border-radius:7px;
      border:1px solid #d4d4d8;
      background:#e5e7eb;
      font:500 .9rem system-ui;
      cursor:pointer;
    }
    .secondary-btn:hover{
      background:#d4d4d8;
    }
        /* Locked state for wordsearch button */
    #generateWordsearchBtn[disabled] {
      opacity: .5;
      cursor: not-allowed;
    }

    .feedback{ text-align:center; min-height:1.1rem; font-size:.9rem; }
    .feedback.ok{ color:#16a34a; }
    .feedback.bad{ color:#dc2626; }

    .small-link{ margin-top:.35rem; font-size:.8rem; text-align:right; text-decoration:underline; cursor:pointer; }

    /* Word search styles */
    #wordsearchStep { margin-top:1rem; }
    .wordsearch-grid { margin-top:.5rem; display:inline-block; border:1px solid #ddd; }
    .wordsearch-grid table { border-collapse:collapse; }
    .wordsearch-grid td {
      width:24px;
      height:24px;
      text-align:center;
      font-weight:600;
      border:1px solid #ddd;
      font-size:.9rem;
      user-select:none;
    }
    .dark .wordsearch-grid td { border-color:#555; }
    .wordsearch-grid td.ws-selected {
      outline:2px solid #f97316;
      outline-offset:-2px;
    }
    .wordsearch-words {
      margin-top:.5rem;
      font-size:.85rem;
    }
    .wordsearch-words .ws-word {
      display:inline-block;
      margin-right:.35rem;
      margin-bottom:.2rem;
      padding:.1rem .35rem;
      border-radius:6px;
      cursor:default;
    }
    .wordsearch-words .ws-word.found {
      background:#bbf7d0;
      text-decoration:line-through;
    }
    .dark .wordsearch-words .ws-word.found {
      background:#166534;
      color:#fff;
    }
     .numbers-progress {
  margin: .25rem 0 .5rem;
}

/* Light vs dark track contrast */
body:not(.dark) .numbers-progress-track {
  width: 100%;
  height: 6px;
  border-radius: 999px;
  background: #e5e7eb;
  overflow: hidden;
}

body.dark .numbers-progress-track {
  width: 100%;
  height: 6px;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.8);
  overflow: hidden;
}

.numbers-progress-fill {
  height: 100%;
  width: 0%;
  border-radius: 999px;
  background: linear-gradient(90deg,#6366f1,#22c55e);
  transition: width .25s ease-out;
}
  /* Numbers mode tabs ‚Äì clearer in both themes */
  .numbers-mode-tabs {
    display: flex;
    gap: .25rem;
    margin: .35rem 0 .25rem;
    flex-wrap: wrap;
  }
  
  .numbers-mode-tab {
    flex: 1 1 auto;
    font-size: .8rem;
    padding: .3rem .6rem;
    border-radius: 999px;
    border: 1px solid transparent;
    cursor: pointer;
    white-space: nowrap;
    transition: background .15s ease, border-color .15s ease, color .15s ease;
  }
  
  /* Light mode: solid pill buttons */
  body:not(.dark) .numbers-mode-tab {
    background: #f9fafb;
    color: #111827;
    border-color: rgba(15, 23, 42, 0.15);
  }
  
  body:not(.dark) .numbers-mode-tab:hover {
    background: #e5f2ff;
    border-color: #0ea5e9;
  }
  
  body:not(.dark) .numbers-mode-tab.active {
    background: #dbeafe;
    border-color: #3b82f6;
    font-weight: 600;
  }
  
  /* Dark mode: stronger contrast */
  body.dark .numbers-mode-tab {
    background: rgba(15, 23, 42, 0.85);
    color: #e5e7eb;
    border-color: rgba(148, 163, 184, 0.6);
  }
  
  body.dark .numbers-mode-tab:hover {
    background: rgba(37, 99, 235, 0.35);
    border-color: #60a5fa;
  }
  
  body.dark .numbers-mode-tab.active {
    background: rgba(37, 99, 235, 0.55);
    border-color: #93c5fd;
    font-weight: 600;
  }

    .numbers-mode-tab.locked {
    opacity: .5;
    cursor: not-allowed;
  }

      .numbers-timer {
    margin: .1rem 0 .2rem;
    font-weight: 700;
    letter-spacing: .03em;
    text-align: left;
  }

  /* Light mode timer */
  body:not(.dark) .numbers-timer {
    font-size: 1.05rem;
    color: #0f172a;
  }

  /* Dark mode timer ‚Äì brighter and clearer */
  body.dark .numbers-timer {
    font-size: 1.15rem;
    color: #e5e7eb;
    text-shadow: 0 0 6px rgba(15,23,42,0.9);
  }

      .numbers-boss-text {
    font-size: .85rem;
    margin: .15rem 0 .25rem;
    color: #6b21a8;
  }

  body.dark .numbers-boss-text {
    color: #e9d5ff;
  }

  #numbersBossGraphicWrapper {
    display: none; /* only shown in boss mode */
    will-change: transform;
  }

  .numbers-boss-graphic {
    width: 120px;
    height: 120px;
    margin: 0;
    display: block;
  }

.boss-arena{
  width: 100%;
  display:flex;
  align-items:flex-end;
  justify-content:center;
  gap: 16px;
}

.boss-arena svg{
  margin: 0;
}

/* ===== Boss shake + defeat (FIXED) ===== */

/* Shake ONLY the boss */
#numbersBossGraphic.numbers-boss-hit{
  animation: numbersBossHit .3s ease;
  will-change: transform;
}

@keyframes numbersBossHit {
  0% { transform: translateX(0); }
  20% { transform: translateX(-4px); }
  40% { transform: translateX(4px); }
  60% { transform: translateX(-2px); }
  80% { transform: translateX(2px); }
  100% { transform: translateX(0); }
}

/* Defeated anim applies to the SVG */
.numbers-boss-graphic.numbers-boss-defeated{
  animation: numbersBossDefeated .5s ease forwards;
}

@keyframes numbersBossDefeated {
  0%   { transform: scale(1) translateY(0); opacity: 1; }
  60%  { transform: scale(1.05) translateY(-6px); opacity: 1; }
  100% { transform: scale(0.8) translateY(10px); opacity: 0; }
}

  .numbers-player-text {
    font-size: .85rem;
    margin: .05rem 0 .25rem;
    color: #dc2626;
  }

  body.dark .numbers-player-text {
    color: #fecaca;
  }
      #numbersCard.numbers-damage-flash {
    animation: numbersDamageFlash .3s ease;
  }

  @keyframes numbersDamageFlash {
    0%   { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.0); background-color: inherit; }
    40%  { box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.3); background-color: rgba(254, 202, 202, 0.4); }
    100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.0); background-color: inherit; }
  }

  body.dark #numbersCard.numbers-damage-flash {
    background-color: rgba(127, 29, 29, 0.5);
  }
      .numbers-boss-graphic .boss-taunt {
    opacity: 0;
    transition: opacity .25s ease;
  }

  .numbers-boss-graphic.numbers-boss-taunt .boss-taunt {
    opacity: 1;
  }

  .numbers-boss-graphic.numbers-boss-taunt {
    animation: numbersBossLaugh .6s ease-in-out infinite alternate;
  }

  @keyframes numbersBossLaugh {
    0%   { transform: translateY(0) scale(1); }
    100% { transform: translateY(-4px) scale(1.03); }
  }
    
.numbers-boss-graphic.gold-boss .boss-body {
  fill: #facc15;   /* gold */
  stroke: #b45309; /* darker outline */
}

    /* ===== Prime Colossus (Final Boss) look ===== */
.numbers-boss-graphic.prime-colossus {
  transform: scale(1.25);
  filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
}

.numbers-boss-graphic.prime-colossus .boss-body {
  fill: #111827;       /* dark armour */
  stroke: #f59e0b;     /* gold trim */
}

.numbers-boss-graphic.prime-colossus text {
  fill: #fbbf24;       /* make symbols pop */
  font-weight: 900;
}

#numbersCard { position: relative; }

.numbers-hero-graphic{
  width: 90px;
  height: 90px;
  display:block;
  transform-origin: 60px 60px;
}

/* --- Hero attack animation --- */
.numbers-hero-graphic.hero-attack .hero-arm,
.numbers-hero-graphic.hero-attack .hero-sword,
.numbers-hero-graphic.hero-attack .hero-guard{

  animation: heroSwing .28s ease-out;
  transform-origin: 42px 58px;
}

@keyframes heroSwing{
  0%   { transform: rotate(0deg) translateX(0); }
  40%  { transform: rotate(-18deg) translateX(1px); }
  100% { transform: rotate(0deg) translateX(0); }
}

/* --- Boss attack animation (bigger than hit shake) --- */
.numbers-boss-graphic.boss-attack{
  animation: bossLunge .35s ease-in-out;
  transform-origin: 60px 80px;
}

@keyframes bossLunge{
  0%   { transform: translateX(0) scale(1); }
  35%  { transform: translateX(-8px) scale(1.05); }
  100% { transform: translateX(0) scale(1); }
}

/* Optional: hero takes damage */
.numbers-hero-graphic.hero-hurt{
  animation: heroHurt .25s ease;
}
@keyframes heroHurt{
  0% { transform: translateX(0); }
  25% { transform: translateX(-3px); }
  50% { transform: translateX(3px); }
  100% { transform: translateX(0); }
}
/* ===== Big centre banner overlay ===== */
.big-banner.hidden { display: none; }

.big-banner {
  position: absolute;
  inset: 0;
  z-index: 50;
  display: grid;
  place-items: center;
  background: rgba(0,0,0,0.65);
  padding: 16px;
}

.big-banner-inner {
  width: min(520px, 92vw);
  border-radius: 18px;
  padding: 18px 16px;
  text-align: center;
  box-shadow: 0 12px 40px rgba(0,0,0,0.35);
  background: rgba(255,255,255,0.92);
  animation: bannerPop .35s ease;
}

body.dark .big-banner-inner {
  background: rgba(20,20,28,0.92);
}

.big-banner-title {
  font-size: 34px;
  font-weight: 900;
  letter-spacing: 1px;
  margin: 6px 0 10px;
}

.big-banner-text {
  font-size: 18px;
  font-weight: 700;
  line-height: 1.25;
  margin: 0 0 14px;
}

.big-banner-close {
  font-size: 16px;
  font-weight: 800;
  padding: 10px 14px;
  border-radius: 12px;
  border: 0;
  cursor: pointer;
}

.big-banner.gold .big-banner-title,
.big-banner.gold .big-banner-text {
  color: #92400e;
}

body.dark .big-banner.gold .big-banner-title,
body.dark .big-banner.gold .big-banner-text {
  color: #fbbf24;
}

.big-banner.win .big-banner-title,
.big-banner.win .big-banner-text {
  color: #166534;
}

body.dark .big-banner.win .big-banner-title,
body.dark .big-banner.win .big-banner-text {
  color: #86efac;
}

@keyframes bannerPop {
  0% { transform: scale(0.92); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}
  </style>
</head>
<body>
  <header>‚úèÔ∏è Spellings Practice</header>
  <button class="toggle-mode" id="modeToggle">üåô</button>

  <section id="mainSection">
    <div class="top-bar">
      <div id="modeLabel"><strong>Spellings practice</strong></div>
      <a href="index.html?home=benton" class="back-link" id="backLink">‚¨Ö Back to Dashboard</a>
    </div>
    <p id="subtitle">Who‚Äôs practising? Enter your name and year to begin.</p>

    <div class="identity-grid" id="identityStep">
      <div class="identity-card">
        <h3>Who‚Äôs practising?</h3>
        <label for="learnerNameInput">Name</label>
        <input id="learnerNameInput" type="text" placeholder="e.g. Jessica F" autocomplete="off" />
        <label for="phaseSelect">Year / Phase</label>
        <select id="phaseSelect">
          <option value="">Select‚Ä¶</option>
          <option value="eyfs">EYFS</option>
          <option value="y3">Year 3</option>
        </select>

        <p class="note">Your score and streak are for this session only.</p>
      </div>

      <div class="identity-card">
        <h3>What are you practising?</h3>
        <div class="mode-options">
        <label id="robinModeOption">
          <input type="radio" name="contentMode" value="robin" checked> Weekly spellings (Year 3)
        </label>
        <label id="eyfsModeOption">
          <input type="radio" name="contentMode" value="eyfs"> EYFS sound blending
        </label>
        <label id="numbersModeOption" style="display:none;">
          <input type="radio" name="contentMode" value="numbers"> Numbers practice (Year 3)
        </label>
      </div>

        <div id="eyfsSetRow" style="margin-top:.5rem; display:none;">
          <label for="eyfsSetSelect">EYFS set</label>
          <select id="eyfsSetSelect"></select>
        </div>

        <button class="start-btn" id="startPracticeBtn">Start practising ‚ñ∂Ô∏è</button>
      </div>
    </div>

    <div id="practiceStep" style="display:none;">
      <!-- Spellings practice card (unchanged) -->
      <div class="practice-card" id="spellingsCard">
        <h3 id="activeLearnerTitle">Practising</h3>
        <p style="font-size:.85rem; color:#666;" id="listLabel"></p>
    
        <div class="stats-row">
          <div class="stat-box">
            <div class="stat-label">Level</div>
            <div class="stat-main" id="statLevel">1</div>
            <div class="stat-label" id="statXP">0 XP</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Streak</div>
            <div class="stat-main" id="statStreak">0</div>
            <div class="stat-label">Best <span id="statBestStreak">0</span></div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Total</div>
            <div class="stat-main"><span id="statCorrect">0</span> / <span id="statTotal">0</span></div>
          </div>
        </div>
    
        <div class="mode-tabs">
          <button class="mode-tab active" data-level="1">Level 1 ‚Äì straight spell it</button>
          <button class="mode-tab disabled" data-level="2">Level 2 ‚Äì missing letters</button>
          <button class="mode-tab disabled" data-level="3">Level 3 ‚Äì clue & audio</button>
        </div>
    
        <div class="practice-word" id="currentWord">start</div>
    
        <button class="secondary-btn" id="speakButton" style="display:none;">üîä Hear the word</button>
        <button class="secondary-btn" id="extraClueButton" style="display:none;">üí° Show letter pattern</button>
    
        <div class="answer-row">
          <input id="answerInput" type="text" placeholder="Type the word here‚Ä¶" autocomplete="off" />
          <button class="primary-btn" id="checkButton"><span id="checkButtonLabel">Check</span></button>
        </div>
    
        <div class="feedback" id="feedback"></div>
        <div class="small-link" id="changeLearnerLink">Change learner / list</div>
      </div>
    
<div class="practice-card" id="numbersCard" style="display:none;">
  <h3 id="numbersTitle">Numbers practice</h3>
  <p style="font-size:.85rem; color:#666;" id="numbersListLabel">
    Using this week‚Äôs numbers.
  </p>

  <!-- Numbers mode tabs: Practice / Streak / Speed / Boss -->
  <div class="numbers-mode-tabs">
    <button class="numbers-mode-tab active" data-nmode="practice">Practice</button>
    <button class="numbers-mode-tab" data-nmode="streak">Streak focus</button>
    <button class="numbers-mode-tab" data-nmode="speed">Speed round</button>
    <button class="numbers-mode-tab" data-nmode="boss">Boss battle</button>
  </div>
  
  <!-- Big centre banner overlay (Gold Boss + Wins) -->
<div id="numbersBigBanner" class="big-banner hidden" aria-live="polite">
  <div class="big-banner-inner">
    <div id="numbersBigBannerTitle" class="big-banner-title">GOLD BOSS!</div>
    <div id="numbersBigBannerText" class="big-banner-text">One life. Stay sharp.</div>
    <button id="numbersBigBannerClose" class="big-banner-close" type="button">OK</button>
  </div>
</div>

  <p id="numbersModeDescription"
     style="font-size:.8rem; color:#666; margin:.15rem 0 .25rem;">
    Answer each question once and see how many you get right.
  </p>

  <!-- Timer (used in speed mode) -->
  <p id="numbersTimerText" class="numbers-timer"></p>

  <!-- Question counter (practice / streak) -->
  <p style="font-size:.8rem; color:#666;" id="numbersProgressText"></p>

  <!-- Progress bar (questions, time, or boss HP depending on mode) -->
  <div class="numbers-progress">
    <div class="numbers-progress-track">
      <div class="numbers-progress-fill" id="numbersProgressFill"></div>
    </div>
  </div>

    <!-- Boss status line -->
  <p id="numbersBossText" class="numbers-boss-text"></p>
  <p id="numbersPlayerText" class="numbers-player-text"></p>

<!-- Boss graphic -->
<div id="numbersBossGraphicWrapper">
  <div class="boss-arena">

    <!-- HERO (unchanged) -->
    <svg id="numbersHeroGraphic" class="numbers-hero-graphic"
         viewBox="0 0 120 120" aria-hidden="true">
      <!-- Head -->
      <circle cx="35" cy="35" r="12"
              fill="#fde68a" stroke="#92400e" stroke-width="3"></circle>

      <!-- Body -->
      <rect x="28" y="48" width="14" height="28" rx="6"
            fill="#60a5fa" stroke="#1e3a8a" stroke-width="3"></rect>

      <!-- Arm -->
      <rect class="hero-arm" x="40" y="52" width="22" height="8" rx="4"
            fill="#fde68a" stroke="#92400e" stroke-width="3"></rect>

      <!-- Sword -->
      <!-- Blade (mostly above the hand) -->
      <rect class="hero-sword" x="58" y="32" width="8" height="34" rx="3"
            fill="#e5e7eb" stroke="#334155" stroke-width="3"></rect>

      <!-- Guard (at the hand) -->
      <rect class="hero-guard" x="54" y="52" width="14" height="5" rx="2"
            fill="#f97316"></rect>
    </svg>

    <!-- BOSS: Prime Colossus (SVG only, keeps the same id + class for your CSS/JS) -->
    <svg id="numbersBossGraphic" class="numbers-boss-graphic"
         viewBox="0 0 120 120" aria-hidden="true">

      <!-- ===== PRIME COLOSSUS BODY (still uses .boss-body so your skins work) ===== -->
      <!-- Shadow base -->
      <ellipse cx="62" cy="100" rx="34" ry="7" fill="rgba(0,0,0,0.18)"></ellipse>

      <!-- Core torso -->
      <rect class="boss-body" x="28" y="28" width="68" height="66" rx="18" ry="18"
            fill="#4f46e5" stroke="#312e81" stroke-width="4"></rect>

      <!-- Shoulder plates -->
      <path d="M28 40 L18 52 L28 56 Z" fill="#1f2937" stroke="#f59e0b" stroke-width="3"></path>
      <path d="M96 40 L106 52 L96 56 Z" fill="#1f2937" stroke="#f59e0b" stroke-width="3"></path>

      <!-- Arm blocks -->
      <rect x="14" y="56" width="18" height="26" rx="8"
            fill="#111827" stroke="#f59e0b" stroke-width="3"></rect>
      <rect x="92" y="56" width="18" height="26" rx="8"
            fill="#111827" stroke="#f59e0b" stroke-width="3"></rect>

      <!-- Chest plate (gold trim) -->
      <rect x="38" y="44" width="48" height="40" rx="12"
            fill="#111827" stroke="#f59e0b" stroke-width="3"></rect>

      <!-- Prime core (glow-y look without filters) -->
      <circle cx="62" cy="64" r="10" fill="#0ea5e9" opacity="0.25"></circle>
      <circle cx="62" cy="64" r="7" fill="#60a5fa" opacity="0.35"></circle>
      <circle cx="62" cy="64" r="4" fill="#fbbf24"></circle>

      <!-- Face window -->
      <rect x="40" y="32" width="44" height="18" rx="9"
            fill="#0b1220" stroke="#f59e0b" stroke-width="3"></rect>

      <!-- Eyes -->
      <circle cx="52" cy="41" r="5.2" fill="white"></circle>
      <circle cx="72" cy="41" r="5.2" fill="white"></circle>
      <circle cx="52" cy="41" r="2.6" fill="#111827"></circle>
      <circle cx="72" cy="41" r="2.6" fill="#111827"></circle>

      <!-- Mouth grille -->
      <rect x="46" y="74" width="32" height="12" rx="5"
            fill="#0b1220" stroke="#f59e0b" stroke-width="3"></rect>
      <rect x="49" y="77" width="4" height="6" fill="#f59e0b"></rect>
      <rect x="56" y="77" width="4" height="6" fill="#f59e0b"></rect>
      <rect x="63" y="77" width="4" height="6" fill="#f59e0b"></rect>
      <rect x="70" y="77" width="4" height="6" fill="#f59e0b"></rect>

      <!-- Crown / horns -->
      <path d="M44 28 L52 16 L58 28" fill="#111827" stroke="#f59e0b" stroke-width="3"></path>
      <path d="M80 28 L72 16 L66 28" fill="#111827" stroke="#f59e0b" stroke-width="3"></path>
      <path d="M58 28 L62 18 L66 28" fill="#111827" stroke="#f59e0b" stroke-width="3"></path>

      <!-- Rune marks (these will pop with your .prime-colossus text styling too) -->
      <text x="34" y="58" font-size="12" font-weight="900" fill="#fbbf24">‚àë</text>
      <text x="88" y="58" font-size="12" font-weight="900" fill="#fbbf24">œÄ</text>
      <text x="36" y="92" font-size="12" font-weight="900" fill="#fbbf24">‚àö</text>
      <text x="86" y="92" font-size="12" font-weight="900" fill="#fbbf24">‚àû</text>

      <!-- Taunt (keep class name so your taunt toggle works) -->
      <text x="62" y="14" text-anchor="middle"
            font-size="12" fill="#f97316"
            class="boss-taunt">Ha ha!</text>
    </svg>

  </div>
</div>

  <!-- Current question -->
  <div class="practice-word" id="currentQuestion">12 √ó 3</div>

  <!-- Answer input and button -->
  <div class="answer-row">
    <input
      id="numbersAnswerInput"
      type="text"
      inputmode="numeric"
      pattern="[0-9]*"
      placeholder="Type the answer‚Ä¶"
      autocomplete="off"
    />
    <button class="primary-btn" id="numbersCheckButton">
      <span id="numbersCheckButtonLabel">Check</span>
    </button>
  </div>

  <!-- Per-question feedback -->
  <div class="feedback" id="numbersFeedback"></div>

  <!-- Medal / how you did this round (practice / speed) -->
  <p style="font-size:.8rem; color:#666; margin-top:.5rem;" id="numbersMedalText"></p>

  <!-- Streak summary (for streak mode) -->
  <p style="font-size:.8rem; color:#666; margin-top:.25rem;" id="numbersStreakSummary"></p>

  <div class="small-link" id="numbersChangeLearnerLink">Change learner / activity</div>
</div>

    <div id="wordsearchStep" style="display:none;">
      <div class="practice-card">
        <h3>Word Search</h3>
        <p style="font-size:.85rem; color:#666;" id="wordsearchStatusText">Locked. Finish all 3 levels to unlock the word search.</p>
        <button class="primary-btn" id="generateWordsearchBtn">Generate word search</button>
        <div id="wordsearchGrid" class="wordsearch-grid"></div>
        <p id="wordsearchWords" class="wordsearch-words"></p>
      </div>
    </div>
  </section>

<script>
/* ========== Theme ========== */
const modeBtn = document.getElementById('modeToggle');
function setInitialTheme(){
  const stored = localStorage.getItem('theme');
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const dark = stored ? stored === 'dark' : prefersDark;
  document.body.classList.toggle('dark', dark);
  modeBtn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
  modeBtn.classList.toggle('sun', dark);
}
modeBtn.onclick = () => {
  const dark = !document.body.classList.contains('dark');
  document.body.classList.toggle('dark', dark);
  localStorage.setItem('theme', dark ? 'dark' : 'light');
  modeBtn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
  modeBtn.classList.toggle('sun', dark);
};

/* ========== Content sources ========== */
/* Fallback list only. Real data comes from Sheet. */
const CURRENT_WEEK_SPELLINGS = ["placeholder"];

/**
 * For now:
 * - Robin's weekly spellings come from Spellings_CurrentWeek via Apps Script
 * - EYFS words come from EYFS_Current via Apps Script
 *
 * Both are "one current set at a time" lists managed in the Sheet.
 */
let robinWordsRemote = [];
let eyfsWordsRemote = [];

// Load Robin's current weekly spellings
async function loadRobinWordsFromSheet() {
  try {
    if (!window.config || !window.config.spellingsUrl) return;
    const url = window.config.spellingsUrl + "?t=" + Date.now();
    const resp = await fetch(url, { cache: "no-store" });
    const data = await resp.json();
    if (Array.isArray(data.robinCurrent)) {
      robinWordsRemote = data.robinCurrent
        .map(w => String(w || "").trim().toLowerCase())
        .filter(w => w.length > 0);
    }
  } catch (err) {
    console.error("Error loading Robin spellings from Sheet", err);
  }
}

// Load EYFS current blending words
async function loadEyfsWordsFromSheet() {
  try {
    if (!window.config || !window.config.spellingsUrl) return;
    const url = window.config.spellingsUrl + "?mode=eyfs&t=" + Date.now();
    const resp = await fetch(url, { cache: "no-store" });
    const data = await resp.json();
    if (Array.isArray(data.eyfsCurrent)) {
      eyfsWordsRemote = data.eyfsCurrent
        .map(w => String(w || "").trim().toLowerCase())
        .filter(w => w.length > 0);
    }
  } catch (err) {
    console.error("Error loading EYFS words from Sheet", err);
  }
}
/* ========== State / DOM ========== */
const learnerNameInput = document.getElementById("learnerNameInput");
const phaseSelect = document.getElementById("phaseSelect");
const modeLabel = document.getElementById("modeLabel");
const subtitle = document.getElementById("subtitle");
const identityStep = document.getElementById("identityStep");
const practiceStep = document.getElementById("practiceStep");
const wordsearchStep = document.getElementById("wordsearchStep");

/* Back button visibility */
const params = new URLSearchParams(window.location.search);
const isHomeMode = params.get('home') === 'benton';
const backLink = document.getElementById("backLink");
if (!isHomeMode && backLink) backLink.style.display = "none";

const startPracticeBtn = document.getElementById("startPracticeBtn");
const eyfsSetRow = document.getElementById("eyfsSetRow");
const eyfsSetSelect = document.getElementById("eyfsSetSelect");

const activeLearnerTitle = document.getElementById("activeLearnerTitle");
const listLabel = document.getElementById("listLabel");
const statLevel = document.getElementById("statLevel");
const statXP = document.getElementById("statXP");
const statStreak = document.getElementById("statStreak");
const statBestStreak = document.getElementById("statBestStreak");
const statCorrect = document.getElementById("statCorrect");
const statTotal = document.getElementById("statTotal");

const modeTabs = document.querySelectorAll(".mode-tab");
const currentWordEl = document.getElementById("currentWord");
const speakButton = document.getElementById("speakButton");
const extraClueButton = document.getElementById("extraClueButton");
const answerInput = document.getElementById("answerInput");
const checkButton = document.getElementById("checkButton");
const checkButtonLabel = document.getElementById("checkButtonLabel");
const feedbackEl = document.getElementById("feedback");
const changeLearnerLink = document.getElementById("changeLearnerLink");

const generateWordsearchBtn = document.getElementById("generateWordsearchBtn");
const wordsearchGridEl = document.getElementById("wordsearchGrid");
const wordsearchWordsEl = document.getElementById("wordsearchWords");
const wordsearchStatusText = document.getElementById("wordsearchStatusText");

/* Numbers DOM (will be null if you haven't added the numbers card yet) */
const spellingsCard = document.getElementById("spellingsCard");
const numbersCard = document.getElementById("numbersCard");

const robinModeOption  = document.getElementById("robinModeOption");
const eyfsModeOption   = document.getElementById("eyfsModeOption");
const numbersModeOption = document.getElementById("numbersModeOption");

const numbersTitle = document.getElementById("numbersTitle");
const numbersListLabel = document.getElementById("numbersListLabel");
const numbersProgressText = document.getElementById("numbersProgressText");
const numbersProgressFill = document.getElementById("numbersProgressFill");
const currentQuestionEl = document.getElementById("currentQuestion");
const numbersAnswerInput = document.getElementById("numbersAnswerInput");
const numbersCheckButton = document.getElementById("numbersCheckButton");
const numbersCheckButtonLabel = document.getElementById("numbersCheckButtonLabel");
const numbersFeedback = document.getElementById("numbersFeedback");
const numbersMedalText = document.getElementById("numbersMedalText");
const numbersChangeLearnerLink = document.getElementById("numbersChangeLearnerLink");

// NEW for numbers modes + streak + speed
const numbersModeTabs = document.querySelectorAll(".numbers-mode-tab");
const numbersModeDescription = document.getElementById("numbersModeDescription");
const numbersStreakSummary = document.getElementById("numbersStreakSummary");
const numbersTimerText = document.getElementById("numbersTimerText");
const numbersBossText = document.getElementById("numbersBossText");
const numbersPlayerText = document.getElementById("numbersPlayerText");
const numbersBossGraphicWrapper = document.getElementById("numbersBossGraphicWrapper");
const numbersBossGraphic = document.getElementById("numbersBossGraphic");
const numbersHeroGraphic = document.getElementById("numbersHeroGraphic");

// Big banner (add here)
const numbersBigBanner = document.getElementById("numbersBigBanner");
const numbersBigBannerTitle = document.getElementById("numbersBigBannerTitle");
const numbersBigBannerText = document.getElementById("numbersBigBannerText");
const numbersBigBannerClose = document.getElementById("numbersBigBannerClose");

/* ===== Section 4.1: Big banner helpers ===== */
function showBigBanner(type, title, text) {
  if (!numbersBigBanner || !numbersBigBannerTitle || !numbersBigBannerText) return;

  numbersBigBanner.classList.remove("hidden", "gold", "win");
  numbersBigBanner.classList.add(type);

  numbersBigBannerTitle.textContent = title || "";
  numbersBigBannerText.textContent = text || "";

  if (numbersBigBannerClose) {
    setTimeout(() => numbersBigBannerClose.focus(), 50);
  }
}

function hideBigBanner() {
  if (!numbersBigBanner) return;
  numbersBigBanner.classList.add("hidden");
  numbersBigBanner.classList.remove("gold", "win");
}
  
/* Core state */
let currentLearner = null;
let currentPhase = "";
let currentContentMode = "robin";   // 'robin' | 'eyfs' | 'numbers'
let parentTestUnlockActive = false;

let currentLevel = 1;
let currentMode = 1;        // 1 = full word, 2 = missing letters, 3 = clue & audio
let awaitingNextWord = false;

let wordQueue = [];
let currentTargetWord = "";

// Session-only stats
let sessionTotal = 0;
let sessionCorrect = 0;
let sessionStreak = 0;
let bestSessionStreak = 0;
let sessionXP = 0;

// Level progression: one cycle of up to 6 words per level (spellings only)
const LEVEL_TARGET_MAX = 6;
let levelCompletion = {
  1: false,
  2: false,
  3: false
};
let levelWordSets = {
  1: new Set(),
  2: new Set(),
  3: new Set()
};

/* Wordsearch state */
let wordsearchCurrentWords = [];
let wordsearchFound = new Set();
const wordsearchColours = [
  "#fee2e2","#dbeafe","#dcfce7","#fef9c3","#ede9fe",
  "#cffafe","#ffedd5","#f5d0fe","#bbf7d0","#fecaca"
];
let selecting = false;
let dragStartRow = null;
let dragStartCol = null;
let selectionCells = [];

/* Numbers practice state */
let numbersQuestions = [];
let numbersIndex = 0;
let numbersAwaitingNext = false;

/* Numbers practice mode: "practice" | "streak" | "speed" */
let numbersGameMode = "practice";

/* Numbers unlocks (session-only) */
let numbersUnlocks = {
  streak: false,
  speed: false,
  boss: false
};

/* Best medal per mode so far in this session
   0 = none, 1 = bronze, 2 = silver, 3 = gold */
let numbersBestMedal = {
  practice: 0,
  streak: 0,
  speed: 0,
  boss: 0
};

const BOSS_MAX_HEALTH = 10;
const GOLD_BOSS_MAX_HEALTH = 12;   // optional if you want HP harder too
const PLAYER_MAX_LIVES = 3;
const GOLD_PLAYER_MAX_LIVES = 1;   // the real ‚Äúperil‚Äù lever
const FINAL_BOSS_MAX_HEALTH = 18;   // Prime Colossus: chunkier
const FINAL_PLAYER_MAX_LIVES = 2;   // still hard, but not cruel

let finalBossActive = false;        // true when fighting the Prime Colossus
let finalBossQueued = false;        // becomes true after Gold Boss is beaten

let bossHealth = BOSS_MAX_HEALTH;
let bossActive = false;
let bossQuestionIndex = 0;
let bossCurrentIndex = 0;
let bossCorrect = 0;
let bossAttempts = 0;

let playerLives = PLAYER_MAX_LIVES;

// Gold boss progression
let bossWinStreak = 0;          // consecutive normal boss wins
let goldBossActive = false;     // we are currently fighting the gold boss (or it is queued)

/* Speed round state */
const SPEED_START_SECONDS = 30;
const SPEED_BONUS_SECONDS = 3; // +3 seconds per correct answer
let speedTimerId = null;
let speedTimeRemaining = 0;
let speedRoundActive = false;
let speedCorrectThisRound = 0;
let speedAttemptedThisRound = 0;
let speedQuestionIndex = 0;

if (numbersBigBannerClose) {
  numbersBigBannerClose.addEventListener("click", hideBigBanner);
}

/* ========== Helpers ========== */
/* Update locks on the numbers mode tabs (practice is always open, others unlock in tiers) */
function updateNumbersModeLocks() {

  if (!numbersModeTabs || !numbersModeTabs.length) return;

  // Boss unlock condition: at least bronze in practice, streak, speed
  const bossShouldUnlock =
    numbersBestMedal.practice >= 1 &&
    numbersBestMedal.streak >= 1 &&
    numbersBestMedal.speed >= 1;

  if (bossShouldUnlock && !numbersUnlocks.boss) {
    numbersUnlocks.boss = true;
  }

  numbersModeTabs.forEach(btn => {
    const mode = btn.dataset.nmode;

    if (mode === "streak") {
      const locked = !numbersUnlocks.streak;
      btn.classList.toggle("locked", locked);
      btn.disabled = locked;
      btn.textContent = locked ? "Streak focus (locked)" : "Streak focus";
    }

    if (mode === "speed") {
      const locked = !numbersUnlocks.speed;
      btn.classList.toggle("locked", locked);
      btn.disabled = locked;
      btn.textContent = locked ? "Speed round (locked)" : "Speed round";
    }

    if (mode === "boss") {
      const locked = !numbersUnlocks.boss;
      btn.classList.toggle("locked", locked);
      btn.disabled = locked;
      btn.textContent = locked ? "Boss battle (locked)" : "Boss battle";
    }
  });
}
  
function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function rebuildWordQueue() {
  const list = getWordList();
  if (!list.length) { wordQueue = []; return; }
  wordQueue = shuffleArray(list.slice());
}

function maskWordForLevel2(word) {
  const clean = String(word || "").trim();
  if (!clean) return "";

  const chars = clean.split("");

  // EYFS: keep it ultra simple, hide exactly one interior letter
  if (currentContentMode === "eyfs") {
    if (chars.length <= 2) {
      if (chars.length === 2) chars[1] = "_";
      return chars.join("");
    }

    const interior = [];
    for (let i = 1; i < chars.length - 1; i++) interior.push(i);
    const idx = interior[Math.floor(Math.random() * interior.length)];
    chars[idx] = "_";
    return chars.join("");
  }

  // Robin (Y3): keep your existing increasing-difficulty behaviour
  if (chars.length <= 2) {
    if (chars.length === 2) chars[1] = "_";
    return chars.join("");
  }

  const interiorIndexes = [];
  for (let i = 1; i < chars.length - 1; i++) {
    interiorIndexes.push(i);
  }

  let lettersToHide = 1;
  if (chars.length >= 4 && chars.length <= 6) lettersToHide = 2;
  if (chars.length >= 7) lettersToHide = 3;
  if (lettersToHide > interiorIndexes.length) lettersToHide = interiorIndexes.length;

  // Shuffle interior indexes
  for (let i = interiorIndexes.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [interiorIndexes[i], interiorIndexes[j]] = [interiorIndexes[j], interiorIndexes[i]];
  }

  for (let k = 0; k < lettersToHide; k++) {
    const idx = interiorIndexes[k];
    chars[idx] = "_";
  }

  return chars.join("");
}
  
function buildClueForLevel3(word) {
  if (!word) return "";
  const clean = String(word).trim();
  if (!clean.length) return "";
  const first = clean[0].toLowerCase();
  const len = clean.length;
  return `Starts with "${first}" ‚Ä¢ ${len} letters`;
}

function buildPatternForLevel3(word) {
  if (!word) return "";
  const clean = String(word).trim();
  if (!clean.length) return "";
  if (clean.length <= 2) return clean;
  const first = clean[0];
  const last = clean[clean.length - 1];
  const middle = Array(clean.length - 2).fill('_').join(' ');
  return `${first} ${middle} ${last}`;
}

function toggleSpeakButton() {
  const canSpeak = typeof window !== "undefined" && "speechSynthesis" in window;

  if (speakButton) {
    if (currentMode === 3 && currentTargetWord && canSpeak) {
      speakButton.style.display = "block";
    } else {
      speakButton.style.display = "none";
    }
  }

  if (extraClueButton) {
    if (currentMode === 3 && currentTargetWord) {
      extraClueButton.style.display = "block";
    } else {
      extraClueButton.style.display = "none";
    }
  }
}

function speakCurrentWord() {
  if (!("speechSynthesis" in window)) return;
  if (!currentTargetWord) return;
  const utter = new SpeechSynthesisUtterance(currentTargetWord);
  utter.lang = "en-GB";
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(utter);
}

function getRadioValue(name){
  const els = document.querySelectorAll(`input[name="${name}"]`);
  for (const el of els) if (el.checked) return el.value;
  return null;
}

function refreshStatsUI() {
  const level = Math.min(5, 1 + Math.floor(sessionXP / 50));
  currentLevel = level;
  statLevel.textContent = level;
  statXP.textContent = `${sessionXP} XP`;
  statStreak.textContent = sessionStreak;
  statBestStreak.textContent = bestSessionStreak;
  statCorrect.textContent = sessionCorrect;
  statTotal.textContent = sessionTotal;
}

/* Level / wordsearch helpers */
function getBaseTargetWords() {
  const list = getWordList()
    .map(w => String(w || "").trim().toLowerCase())
    .filter(Boolean);
  const unique = Array.from(new Set(list));
  return unique.slice(0, LEVEL_TARGET_MAX);
}

function updateLevelTabsUI() {
  const done1 = levelCompletion[1];
  const done2 = levelCompletion[2];

  modeTabs.forEach(tab => {
    const lvl = Number(tab.dataset.level);
    if (lvl === 1) {
      tab.classList.remove('disabled');
    } else if (lvl === 2) {
      tab.classList.toggle('disabled', !done1);
    } else if (lvl === 3) {
      tab.classList.toggle('disabled', !done2);
    }
  });
}

function updateWordsearchLockUI() {
  if (!generateWordsearchBtn) return;
  const allDone = levelCompletion[1] && levelCompletion[2] && levelCompletion[3];

  if (allDone) {
    generateWordsearchBtn.disabled = false;
    generateWordsearchBtn.textContent = "Generate word search";
    if (wordsearchStatusText) {
      wordsearchStatusText.textContent = "Unlocked! You completed all 3 levels. Enjoy the word search.";
    }
  } else {
    generateWordsearchBtn.disabled = true;
    generateWordsearchBtn.textContent = "Locked ‚Äì finish all 3 levels first";
    if (wordsearchStatusText) {
      wordsearchStatusText.textContent = "Locked. Complete one cycle of up to 6 words in Levels 1, 2 and 3 to unlock.";
    }
  }
}

function parentUnlockAll() {
  console.log("[UNLOCK] parentUnlockAll() fired");

  // ---- Spellings levels / wordsearch ----
  if (typeof levelCompletion !== "undefined") {
    levelCompletion[1] = true;
    levelCompletion[2] = true;
    levelCompletion[3] = true;
  }

  if (typeof levelWordSets !== "undefined") {
    if (levelWordSets[1]) levelWordSets[1].clear();
    if (levelWordSets[2]) levelWordSets[2].clear();
    if (levelWordSets[3]) levelWordSets[3].clear();
  }

  if (typeof updateLevelTabsUI === "function") updateLevelTabsUI();
  if (typeof updateWordsearchLockUI === "function") updateWordsearchLockUI();

  // ---- Numbers unlocks (if present) ----
  if (typeof numbersUnlocks !== "undefined") {
    numbersUnlocks.streak = true;
    numbersUnlocks.speed = true;
    numbersUnlocks.boss = true;
  }

  if (typeof numbersBestMedal !== "undefined") {
    numbersBestMedal.practice = 3;
    numbersBestMedal.streak = 3;
    numbersBestMedal.speed = 3;
    if (typeof numbersBestMedal.boss !== "undefined") {
      numbersBestMedal.boss = Math.max(numbersBestMedal.boss || 0, 1);
    }
  }

  if (typeof updateNumbersModeLocks === "function") updateNumbersModeLocks();

  console.log("[UNLOCK] done");
}

function registerCorrectAnswerForCurrentLevel(word) {
  // Numbers mode does NOT affect level / wordsearch unlock
  if (currentContentMode === "numbers") return;
  if (!word) return;

  const lvl = currentMode; // 1,2,3
  if (lvl < 1 || lvl > 3) return;

  const baseTargets = getBaseTargetWords();
  if (!baseTargets.length) return;

  const lower = word.trim().toLowerCase();
  if (!baseTargets.includes(lower)) return;

  const set = levelWordSets[lvl];
  set.add(lower);

  const targetCount = Math.min(LEVEL_TARGET_MAX, baseTargets.length);
  if (!levelCompletion[lvl] && set.size >= targetCount) {
    levelCompletion[lvl] = true;

    if (typeof confetti === "function") {
      confetti({
        particleCount: 120,
        spread: 70,
        origin: { y: 0.7 }
      });
    }

    feedbackEl.textContent = `Level ${lvl} complete ‚Äì nice work!`;
    feedbackEl.className = "feedback ok";

    updateLevelTabsUI();
    updateWordsearchLockUI();
  }
}

function updateBossUI() {
  if (numbersGameMode === "boss") {
    if (numbersBossGraphicWrapper) {
      numbersBossGraphicWrapper.style.display = "block";
    }

    const maxHP = finalBossActive
    ? FINAL_BOSS_MAX_HEALTH
    : (goldBossActive ? GOLD_BOSS_MAX_HEALTH : BOSS_MAX_HEALTH);


    if (numbersBossText) {
      const title = finalBossActive ? "Prime Colossus" : (goldBossActive ? "Gold Boss" : "Boss");
      numbersBossText.textContent =
        title + " HP: " + bossHealth + " / " + maxHP;
    }

    if (numbersPlayerText) {
      let hearts = "";
      for (let i = 0; i < playerLives; i++) {
        hearts += (i ? " " : "") + "‚ù§Ô∏è";
      }
      if (!hearts) hearts = "üíÄ";
      numbersPlayerText.textContent = "Your lives: " + hearts;
    }

    if (numbersProgressFill) {
      const pct = (bossHealth / maxHP) * 100;
      numbersProgressFill.style.width = pct + "%";
    }
  } else {
    if (numbersBossText) numbersBossText.textContent = "";
    if (numbersPlayerText) numbersPlayerText.textContent = "";

    if (numbersBossGraphicWrapper) {
      numbersBossGraphicWrapper.style.display = "none";
    }
    if (numbersBossGraphic) {
      numbersBossGraphic.classList.remove(
        "numbers-boss-hit",
        "numbers-boss-defeated",
        "numbers-boss-taunt",
        "gold-boss"
      );
    }
  }
}

function resetBossState() {
  // Gold boss stays active until beaten
  const maxHP = finalBossActive
    ? FINAL_BOSS_MAX_HEALTH
    : (goldBossActive ? GOLD_BOSS_MAX_HEALTH : BOSS_MAX_HEALTH);
  
  const maxLives = finalBossActive
    ? FINAL_PLAYER_MAX_LIVES
    : (goldBossActive ? GOLD_PLAYER_MAX_LIVES : PLAYER_MAX_LIVES);

  bossHealth = maxHP;
  bossActive = false;
  bossQuestionIndex = 0;
  bossCurrentIndex = 0;
  bossCorrect = 0;
  bossAttempts = 0;

  playerLives = maxLives;

  updateBossUI();

  // Show the hard-mode warning ONLY when gold boss is active
  if (goldBossActive) {
    showBigBanner(
      "gold",
      "GOLD BOSS!",
      "Hard Mode: ONE life.\nDefeat this boss to see what‚Äôs watching you."
    );
  }

  if (numbersBossGraphicWrapper) {
    numbersBossGraphicWrapper.style.display =
      (numbersGameMode === "boss") ? "block" : "none";
  }

if (numbersBossGraphic) {
  numbersBossGraphic.classList.remove(
    "numbers-boss-hit",
    "numbers-boss-defeated",
    "numbers-boss-taunt",
    "gold-boss",
    "prime-colossus"
  );

  // Apply correct boss skin
  if (finalBossActive) {
    numbersBossGraphic.classList.add("prime-colossus");
  } else if (goldBossActive) {
    numbersBossGraphic.classList.add("gold-boss");
  }
}

  const card = document.getElementById("numbersCard");
  if (card) {
    card.classList.remove("numbers-damage-flash");
  }

  if (numbersFeedback) {
    numbersFeedback.textContent = "";
    numbersFeedback.className = "feedback";
  }
  if (numbersMedalText) numbersMedalText.textContent = "";
  if (numbersStreakSummary) numbersStreakSummary.textContent = "";
  if (numbersTimerText) numbersTimerText.textContent = "";
}
  
function showBossQuestion() {
  if (!numbersQuestions.length) {
    if (currentQuestionEl) currentQuestionEl.textContent = "No questions set.";
    return;
  }

  if (bossQuestionIndex >= numbersQuestions.length) {
    bossQuestionIndex = 0;
  }

  const q = numbersQuestions[bossQuestionIndex];
  bossCurrentIndex = bossQuestionIndex;
  bossQuestionIndex++;

  const display =
    (typeof prettyPrintQuestion === "function")
      ? prettyPrintQuestion(q.question)
      : q.question;

  if (currentQuestionEl) currentQuestionEl.textContent = display;

  if (numbersAnswerInput) {
    numbersAnswerInput.value = "";
    numbersAnswerInput.focus();
  }
  if (numbersFeedback) {
    numbersFeedback.textContent = "";
    numbersFeedback.className = "feedback";
  }
}

  function triggerHeroAttack() {
  if (!numbersHeroGraphic) return;
  numbersHeroGraphic.classList.remove("hero-attack");
  requestAnimationFrame(() => {
    numbersHeroGraphic.classList.add("hero-attack");
  });
}

function triggerBossAttack() {
  if (!numbersBossGraphic) return;
  numbersBossGraphic.classList.remove("boss-attack");
  requestAnimationFrame(() => {
    numbersBossGraphic.classList.add("boss-attack");
  });
}

function triggerHeroHurt() {
  if (!numbersHeroGraphic) return;
  numbersHeroGraphic.classList.remove("hero-hurt");
  requestAnimationFrame(() => {
    numbersHeroGraphic.classList.add("hero-hurt");
  });
}

/* ========== Word list & practice (spellings) ========== */
/* ========== Word list & practice (spellings) ========== */
function getWordList() {
  if (currentContentMode === "robin") {
    // Robin (Y3): prefer Sheet, fall back to local list
    const fromSheet = robinWordsRemote.length ? robinWordsRemote : null;
    const source = fromSheet || CURRENT_WEEK_SPELLINGS;
    return source.slice();
  } else if (currentContentMode === "eyfs") {
    // EYFS: always use whatever is in EYFS_Current
    if (eyfsWordsRemote.length) {
      return eyfsWordsRemote.slice();
    }
    // No EYFS words set yet
    return [];
  } else {
    // Numbers mode uses a different loop, no words
    return [];
  }
}

function pickNextWord() {
  if (!wordQueue.length) rebuildWordQueue();
  if (!wordQueue.length) {
    currentWordEl.textContent = "No words.";
    currentTargetWord = "";
    toggleSpeakButton();
    return;
  }

  const next = wordQueue.shift();
  currentTargetWord = next;

  let toShow = next;
  if (currentMode === 2) {
    toShow = maskWordForLevel2(next);
  } else if (currentMode === 3) {
    toShow = buildClueForLevel3(next);
  }

  currentWordEl.textContent = toShow;
  answerInput.value = "";
  answerInput.focus();
  feedbackEl.textContent = "";
  awaitingNextWord = false;
  checkButtonLabel.textContent = "Check";
  toggleSpeakButton();
}

function handleAnswer() {
  if (!currentLearner) return;

  if (awaitingNextWord){ 
    pickNextWord(); 
    return; 
  }

  const target = currentTargetWord.trim().toLowerCase();
  const guess = answerInput.value.trim().toLowerCase();

  if (!target || !guess){
    feedbackEl.textContent = "Type the word first.";
    feedbackEl.className = "feedback bad";
    return;
  }

  sessionTotal++;

  if (guess === target){
    sessionCorrect++;
    sessionStreak++;
    bestSessionStreak = Math.max(bestSessionStreak, sessionStreak);
    sessionXP += 10;

    feedbackEl.textContent = "Nice, that‚Äôs correct! üéâ";
    feedbackEl.className = "feedback ok";

    // Track towards unlocking next levels / wordsearch
    registerCorrectAnswerForCurrentLevel(currentTargetWord);
  } else {
    feedbackEl.textContent = `Close ‚Äì the correct spelling is ‚Äú${target}‚Äù.`;
    feedbackEl.className = "feedback bad";
    sessionStreak = 0;
  }

  refreshStatsUI();
  awaitingNextWord = true;
  checkButtonLabel.textContent = "Next word";
}

/* ========== Numbers: backend + loop ========== */

// Load this week's numbers from the Numbers_Current sheet
async function loadNumbersFromSheet() {
  numbersQuestions = [];
  try {
    if (!window.config || !window.config.spellingsUrl) return;
    const url = window.config.spellingsUrl + '?mode=numbers&t=' + Date.now();
    const resp = await fetch(url, { cache: 'no-store' });
    const data = await resp.json();
    if (Array.isArray(data.numbersCurrent)) {
      numbersQuestions = data.numbersCurrent
        .map(item => ({
          question: String(item.question || "").trim(),
          answer: String(item.answer || "").trim()
        }))
        .filter(q => q.question && q.answer);
    }
  } catch (err) {
    console.error('Error loading numbers from Sheet', err);
  }
}

// Turn "12 x 3" / "36 / 3" into "12 √ó 3" / "36 √∑ 3" for display
function prettyPrintQuestion(raw) {
  if (!raw) return "";
  let s = String(raw);

  // Normalise spacing
  s = s.replace(/\s+/g, " ").trim();

  // Replace operator characters with nicer symbols
  s = s.replace(/[xX*]/g, "√ó");
  s = s.replace(/\//g, "√∑");

  return s;
}

function updateNumbersModeDescription() {
  if (!numbersModeDescription) return;

  if (numbersGameMode === "streak") {
    numbersModeDescription.textContent =
      "Try to build your longest streak of correct answers this round.";
  }
  else if (numbersGameMode === "speed") {
    numbersModeDescription.textContent =
      "30 seconds. Answer as many as you can ‚Äî each correct answer adds extra time!";
  }
  else if (numbersGameMode === "boss") {
    numbersModeDescription.textContent =
      "‚öîÔ∏è Beat the boss by answering each question! But be warned ‚Äî a wrong move costs you a life!";
  }
  else {
    // practice mode fallback
    numbersModeDescription.textContent =
      "Answer each question once and see how many you get right.";
  }
}

function updateSpeedTimerUI() {
  if (!numbersTimerText) return;
  numbersTimerText.textContent = `‚è± ${Math.max(0, speedTimeRemaining)}s left`;

  // In speed mode, reuse the bar as time remaining
  if (numbersProgressFill) {
    const pct = SPEED_START_SECONDS
      ? Math.max(0, Math.min(1, speedTimeRemaining / SPEED_START_SECONDS)) * 100
      : 0;
    numbersProgressFill.style.width = pct + "%";
  }
}

/* Show next question in speed mode (loops through the list) */
function showSpeedQuestion() {
  if (!numbersQuestions.length) {
    if (currentQuestionEl) currentQuestionEl.textContent = "No questions set.";
    return;
  }

  if (speedQuestionIndex >= numbersQuestions.length) {
    speedQuestionIndex = 0;
  }

  const q = numbersQuestions[speedQuestionIndex];
  speedQuestionIndex++;

  const display =
    (typeof prettyPrintQuestion === "function")
      ? prettyPrintQuestion(q.question)
      : q.question;

  if (currentQuestionEl) currentQuestionEl.textContent = display;

  if (numbersAnswerInput) {
    numbersAnswerInput.value = "";
    numbersAnswerInput.focus();
  }
  if (numbersFeedback) {
    numbersFeedback.textContent = "";
    numbersFeedback.className = "feedback";
  }
  if (numbersMedalText) numbersMedalText.textContent = "";
  if (numbersStreakSummary) numbersStreakSummary.textContent = "";

  // In speed mode, question counter is less important
  if (numbersProgressText) {
    numbersProgressText.textContent = "";
  }
}

  function stopSpeedRound(showSummary) {
  if (speedTimerId !== null) {
    clearInterval(speedTimerId);
    speedTimerId = null;
  }
  speedRoundActive = false;

  if (!showSummary) return;

  if (currentQuestionEl) currentQuestionEl.textContent = "Time‚Äôs up!";

  const got = speedCorrectThisRound;
  const total = speedAttemptedThisRound;

  if (numbersFeedback) {
    let msg;
    if (!total) {
      msg = "No questions answered this round.";
    } else {
      const accuracy = total ? Math.round((got / total) * 100) : 0;
      msg =
        `You answered ${total} question${total === 1 ? "" : "s"}, ` +
        `${got} correct (${accuracy}%).`;
    }
    numbersFeedback.textContent = msg;
    numbersFeedback.className = "feedback ok";
  }

  if (numbersMedalText && total) {
    const accuracy = total ? (got / total) : 0;
    let medal;
    let tier = 0;

    if (got === 0) {
      medal = "Keep trying ‚Äì another round will help.";
      tier = 0;
    } else if (got >= 10 && accuracy >= 0.8) {
      medal = "üèÖ Gold ‚Äì lightning fast and accurate!";
      tier = 3;
    } else if ((got >= 8 && accuracy >= 0.6) || accuracy >= 0.75) {
      medal = "ü•à Silver ‚Äì great speed.";
      tier = 2;
    } else if (got >= 5 || accuracy >= 0.5) {
      medal = "ü•â Bronze ‚Äì good effort.";
      tier = 1;
    } else {
      medal = "Nice effort ‚Äì have another go.";
      tier = 0;
    }

    numbersMedalText.textContent = medal;
    numbersBestMedal.speed = Math.max(numbersBestMedal.speed, tier);
        // Re-check unlocks now that Speed has a medal
    updateNumbersModeLocks();
  } else if (numbersMedalText) {
    numbersMedalText.textContent = "";
  }

  if (numbersStreakSummary) {
    numbersStreakSummary.textContent = "";
  }

  // Confetti only if at least one correct
  if (typeof confetti === "function" && got > 0) {
    confetti({
      particleCount: 150,
      spread: 70,
      origin: { y: 0.7 }
    });
  }

  if (numbersCheckButtonLabel) numbersCheckButtonLabel.textContent = "Again";
}

function startSpeedRound() {
  if (!numbersQuestions.length) {
    if (currentQuestionEl) currentQuestionEl.textContent = "No questions set.";
    if (numbersFeedback) {
      numbersFeedback.textContent =
        "Ask an adult to add some questions to the Numbers_Current sheet.";
      numbersFeedback.className = "feedback bad";
    }
    return;
  }

  // Reset round stats
  speedTimeRemaining = SPEED_START_SECONDS;
  speedCorrectThisRound = 0;
  speedAttemptedThisRound = 0;
  speedQuestionIndex = 0;
  speedRoundActive = true;

  // Reset shared stats for this run
  sessionTotal = 0;
  sessionCorrect = 0;
  sessionStreak = 0;
  bestSessionStreak = 0;
  sessionXP = 0;
  refreshStatsUI();

  if (numbersMedalText) numbersMedalText.textContent = "";
  if (numbersStreakSummary) numbersStreakSummary.textContent = "";
  if (numbersProgressText) numbersProgressText.textContent = "";
  if (numbersFeedback) {
    numbersFeedback.textContent = "";
    numbersFeedback.className = "feedback";
  }

  if (numbersCheckButtonLabel) numbersCheckButtonLabel.textContent = "Check";

  updateSpeedTimerUI();
  showSpeedQuestion();

  if (speedTimerId !== null) {
    clearInterval(speedTimerId);
  }
  speedTimerId = setInterval(() => {
    speedTimeRemaining--;
    if (speedTimeRemaining <= 0) {
      speedTimeRemaining = 0;
      updateSpeedTimerUI();
      stopSpeedRound(true);
    } else {
      updateSpeedTimerUI();
    }
  }, 1000);
}
  
function showCurrentNumberQuestion() {
  // Speed mode uses its own question display
  if (numbersGameMode === "speed" || numbersGameMode === "boss") {
    return;
  }

  // No questions at all
  if (!numbersQuestions.length) {
    if (currentQuestionEl) currentQuestionEl.textContent = "No questions set.";
    if (numbersFeedback) {
      numbersFeedback.textContent =
        "Ask an adult to add some questions to the Numbers_Current sheet.";
      numbersFeedback.className = "feedback bad";
    }
    if (numbersCheckButtonLabel) numbersCheckButtonLabel.textContent = "Check";
    if (numbersProgressText) numbersProgressText.textContent = "";
    if (numbersProgressFill) numbersProgressFill.style.width = "0%";
    if (numbersMedalText) numbersMedalText.textContent = "";
    if (numbersStreakSummary) numbersStreakSummary.textContent = "";
    if (numbersTimerText) numbersTimerText.textContent = "";
    return;
  }

  // End of round (practice / streak)
  if (numbersIndex >= numbersQuestions.length) {
    const got = sessionCorrect;
    const total = sessionTotal;

    if (currentQuestionEl) currentQuestionEl.textContent = "All done!";

    if (numbersFeedback) {
      let msg;
      if (!total) {
        msg = "No questions answered this round.";
      } else if (got === total) {
        msg = "Brilliant ‚Äì you got all " + total + " correct! üéâ";
      } else if (got === 0) {
        msg = "You‚Äôve tried all " + total + " questions. Let‚Äôs have another go and see if we can get some right.";
      } else {
        msg = "Nice work ‚Äì you got " + got + " out of " + total + " correct.";
      }
      numbersFeedback.textContent = msg;
      numbersFeedback.className = "feedback ok";
    }

    if (numbersProgressText) {
      numbersProgressText.textContent = "All questions finished for this round.";
    }

    // Fill progress bar to 100%
    if (numbersProgressFill) numbersProgressFill.style.width = "100%";

       // Medal award text (practice / streak) + track best medal
    if (numbersMedalText && total) {
      const accuracy = total ? got / total : 0;
      let medal;
      let tier = 0;

      if (got === total) {
        medal = "üèÖ Gold ‚Äì full marks!";
        tier = 3;
      } else if (accuracy >= 0.8) {
        medal = "ü•à Silver ‚Äì great job.";
        tier = 2;
      } else if (accuracy >= 0.5) {
        medal = "ü•â Bronze ‚Äì you're getting there.";
        tier = 1;
      } else {
        medal = "Keep going ‚Äì another round will help.";
        tier = 0;
      }
      numbersMedalText.textContent = medal;

      if (numbersGameMode === "practice") {
        numbersBestMedal.practice = Math.max(numbersBestMedal.practice, tier);
      } else if (numbersGameMode === "streak") {
        numbersBestMedal.streak = Math.max(numbersBestMedal.streak, tier);
      }
    } else if (numbersMedalText) {
      numbersMedalText.textContent = "";
    }
    // Confetti only if at least one correct
    if (typeof confetti === "function" && sessionCorrect > 0) {
      confetti({
        particleCount: 150,
        spread: 70,
        origin: { y: 0.7 }
      });
    }
        // Tiered unlocks:
    // 1) Finish a Practice round ‚Üí unlock Streak
    if (numbersGameMode === "practice" && !numbersUnlocks.streak) {
      numbersUnlocks.streak = true;
      updateNumbersModeLocks();
    }

    // 2) Finish a Streak round ‚Üí unlock Speed
    if (numbersGameMode === "streak" && !numbersUnlocks.speed) {
      numbersUnlocks.speed = true;
      updateNumbersModeLocks();
    }

    if (numbersCheckButtonLabel) numbersCheckButtonLabel.textContent = "Again";
    numbersAwaitingNext = true;
    return;
  }

  // Normal question display (practice / streak)
  const q = numbersQuestions[numbersIndex];

  // Question counter
  if (numbersProgressText) {
    numbersProgressText.textContent =
      "Question " + (numbersIndex + 1) + " of " + numbersQuestions.length;
  }

  // Progress bar (questions done)
  if (numbersProgressFill) {
    const total = numbersQuestions.length;
    const done = numbersIndex; // answered so far
    const pct = total ? (done / total) * 100 : 0;
    numbersProgressFill.style.width = pct + "%";
  }

  // Clear any medal & streak mid-round
  if (numbersMedalText) numbersMedalText.textContent = "";
  if (numbersStreakSummary) numbersStreakSummary.textContent = "";
  if (numbersTimerText && numbersGameMode !== "speed") {
    numbersTimerText.textContent = "";
  }

  // Show the question
  const display =
    (typeof prettyPrintQuestion === "function")
      ? prettyPrintQuestion(q.question)
      : q.question;

  if (currentQuestionEl) currentQuestionEl.textContent = display;

  if (numbersAnswerInput) {
    numbersAnswerInput.value = "";
    numbersAnswerInput.focus();
  }
  if (numbersFeedback) {
    numbersFeedback.textContent = "";
    numbersFeedback.className = "feedback";
  }
  if (numbersCheckButtonLabel) numbersCheckButtonLabel.textContent = "Check";

  numbersAwaitingNext = false;
}

function handleNumbersAnswer() {
  if (!currentLearner) return;
  if (!numbersQuestions.length) return;

  // SPEED MODE
  if (numbersGameMode === "speed") {
    // Start / restart
    if (!speedRoundActive && (!speedTimerId || speedTimeRemaining === 0)) {
      startSpeedRound();
      return;
    }

    // Normal answer during speed round
    const qIndex = (speedQuestionIndex - 1 + numbersQuestions.length) % numbersQuestions.length;
    const q = numbersQuestions[qIndex];
    const guessRaw = numbersAnswerInput ? numbersAnswerInput.value.trim() : "";
    if (!guessRaw) {
      if (numbersFeedback) {
        numbersFeedback.textContent = "Type an answer first.";
        numbersFeedback.className = "feedback bad";
      }
      return;
    }

    speedAttemptedThisRound++;
    sessionTotal++;

    const correct = q.answer.trim();
    if (guessRaw === correct) {
      speedCorrectThisRound++;
      sessionCorrect++;
      sessionStreak++;
      bestSessionStreak = Math.max(bestSessionStreak, sessionStreak);
      sessionXP += 10;

      // Add bonus time
      speedTimeRemaining += SPEED_BONUS_SECONDS;
      if (speedTimeRemaining > SPEED_START_SECONDS + 30) {
        speedTimeRemaining = SPEED_START_SECONDS + 30; // soft cap
      }

      if (numbersFeedback) {
        numbersFeedback.textContent = "Correct! +" + SPEED_BONUS_SECONDS + "s üéâ";
        numbersFeedback.className = "feedback ok";
      }
    } else {
      sessionStreak = 0;
      if (numbersFeedback) {
        numbersFeedback.textContent = "Almost ‚Äì the answer is " + correct + ".";
        numbersFeedback.className = "feedback bad";
      }
    }

    refreshStatsUI();
    updateSpeedTimerUI();
    showSpeedQuestion();
    return;
  }

    // BOSS MODE
    if (numbersGameMode === "boss") {
      // Start battle
      if (!bossActive && bossAttempts === 0) {
          if (finalBossQueued) {
      finalBossActive = true;
      finalBossQueued = false;
  
      showBigBanner(
        "gold",
        "‚öîÔ∏è PRIME COLOSSUS",
        "A towering enemy of PRIME power arrives.\nTwo lives only. Stay sharp!"
      );
    } else {
    finalBossActive = false;
  }
      resetBossState();
      bossActive = true;
      if (numbersCheckButtonLabel) {
        numbersCheckButtonLabel.textContent = "Attack!";
      }
      showBossQuestion();
      return;
    }

    if (!bossActive) {
      // Battle finished, clicking "Fight again"
      resetBossState();
      bossActive = true;
      if (numbersCheckButtonLabel) {
        numbersCheckButtonLabel.textContent = "Attack!";
      }
      showBossQuestion();
      return;
    }

    const q = numbersQuestions[bossCurrentIndex];
    const guessRaw = numbersAnswerInput ? numbersAnswerInput.value.trim() : "";
    if (!guessRaw) {
      if (numbersFeedback) {
        numbersFeedback.textContent = "Type an answer first.";
        numbersFeedback.className = "feedback bad";
      }
      return;
    }

    bossAttempts++;
    sessionTotal++;

    const correct = q.answer.trim();
    if (guessRaw === correct) {
      bossCorrect++;
      bossHealth = Math.max(0, bossHealth - 1);
      sessionCorrect++;
      sessionStreak++;
      bestSessionStreak = Math.max(bestSessionStreak, sessionStreak);
      sessionXP += 15; // extra XP for boss hits

      if (numbersFeedback) {
        numbersFeedback.textContent = "Hit! The boss takes damage.";
        numbersFeedback.className = "feedback ok";
      }

    // Shake the boss on every hit (BOSS ONLY, not hero)
    if (numbersBossGraphic) {
      numbersBossGraphic.classList.remove("numbers-boss-hit");
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          numbersBossGraphic.classList.add("numbers-boss-hit");
        });
      });
    }

      triggerHeroAttack();
  } else {
      sessionStreak = 0;
      playerLives = Math.max(0, playerLives - 1);

      if (numbersFeedback) {
        numbersFeedback.textContent =
          "Miss! You lose a life. The answer was " + correct + ".";
        numbersFeedback.className = "feedback bad";
      }

      // Flash the card to show damage taken (quick pulse, then clear)
      const card = document.getElementById("numbersCard");
      if (card) {
        card.classList.add("numbers-damage-flash");
        setTimeout(() => {
          card.classList.remove("numbers-damage-flash");
        }, 250);
      }
    triggerBossAttack();
    triggerHeroHurt();
    }

    refreshStatsUI();
    updateBossUI();

    // Check player defeat first
    if (playerLives <= 0) {
      bossActive = false;
      if (currentQuestionEl) currentQuestionEl.textContent = "You were defeated!";
      if (numbersBossText) {
        numbersBossText.textContent = "The boss wins this time. Try again!";
      }
      if (numbersCheckButtonLabel) {
        numbersCheckButtonLabel.textContent = "Try again";
      }

      // Boss taunts you
      if (numbersBossGraphic) {
        numbersBossGraphic.classList.remove("numbers-boss-hit", "numbers-boss-defeated");
        numbersBossGraphic.classList.add("numbers-boss-taunt");
      }

  // Losing breaks the normal win streak
  bossWinStreak = 0;

  // If this is a gold boss attempt, it stays gold until beaten
  // (so we do NOT set goldBossActive = false here)
      // No confetti on player defeat
      return;
    }

    // Then check boss defeat
    if (bossHealth <= 0) {
      bossActive = false;
      // ---- Gold Boss progression ----
  if (goldBossActive) {
  // We just beat the gold boss
  goldBossActive = false;
  bossWinStreak = 0;

  finalBossQueued = true;

  if (numbersBossText) {
    numbersBossText.textContent += " Gold Boss beaten! üèÜ";
  }
} else {
  // Normal boss win
  bossWinStreak++;

  // After 2 normal wins, the NEXT boss becomes gold
  if (bossWinStreak >= 2) {
    goldBossActive = true;

    // Big tease banner (this is the ‚Äúkeep playing‚Äù hook)
    showBigBanner(
      "gold",
      "‚ö†Ô∏è A GREATER CHALLENGE AWAKENS",
      "You‚Äôve beaten two bosses.\nKeep going and you won‚Äôt face just a Gold Boss‚Ä¶\nSomething bigger is coming."
    );
  }
}
// ---- End Gold Boss progression ----
      
      // ===== Section 6: Big WIN banner (only when Gold Boss was beaten) =====
if (!goldBossActive && bossWinStreak === 0) {
  showBigBanner(
    "win",
    "YOU FEEL THE GROUND TREMBLE",
    "The Gold Boss is defeated‚Ä¶\nBut something far stronger has awakened.\nKeep playing to challenge it."
  );
}

  // Extra confetti blasts (you already use confetti() below)
  try {
    if (typeof confetti === "function") {
      confetti({ particleCount: 220, spread: 80, origin: { y: 0.7 } });
      setTimeout(() => confetti({ particleCount: 180, spread: 70, origin: { y: 0.7 } }), 250);
      setTimeout(() => confetti({ particleCount: 140, spread: 65, origin: { y: 0.7 } }), 500);
    }
  } catch {}
      if (currentQuestionEl) currentQuestionEl.textContent = "Boss defeated!";
      const wrong = bossAttempts - bossCorrect;
      if (numbersBossText) {
        // Stats first
        numbersBossText.textContent =
          "You beat the boss with " + bossCorrect + " hits and " + wrong + " misses.";
      
        // Then teaser (depends what just happened)
        if (bossWinStreak === 1 && !goldBossActive) {
          numbersBossText.textContent += " The boss trembles‚Ä¶ something stronger has noticed you.";
        }
      
        if (goldBossActive) {
          // This line will only show during the moment goldBossActive is still true
          numbersBossText.textContent += " ‚ö†Ô∏è A greater challenge is waking up‚Ä¶";
        }
      
        if (!goldBossActive && bossWinStreak === 0) {
          // This is your ‚Äújust beat the Gold Boss‚Äù state
          numbersBossText.textContent += " You feel the ground tremble‚Ä¶ something far stronger has awakened.";
        }
      }
      // Basic "medal" for boss if needed later
      let tier = 0;
      if (bossCorrect >= 10 && wrong === 0) {
        tier = 3;
      } else if (bossCorrect >= 10) {
        tier = 2;
      } else if (bossCorrect >= 5) {
        tier = 1;
      }
      numbersBestMedal.boss = Math.max(numbersBestMedal.boss, tier);

      // Defeat animation
      if (numbersBossGraphic) {
        numbersBossGraphic.classList.remove("numbers-boss-hit", "numbers-boss-taunt");
        numbersBossGraphic.classList.add("numbers-boss-defeated");
      }

      if (typeof confetti === "function") {
        confetti({
          particleCount: 180,
          spread: 70,
          origin: { y: 0.7 }
        });
      }

      if (numbersCheckButtonLabel) {
        numbersCheckButtonLabel.textContent = "Fight again";
      }
      return;
    }

    // Continue battle: next question
    showBossQuestion();
    return;
  }

  // PRACTICE / STREAK MODE BELOW

  // If we are waiting for "Next question" OR "Again"
  if (numbersAwaitingNext) {
    // Finished the round, "Again" clicked
    if (numbersIndex >= numbersQuestions.length) {
      numbersIndex = 0;
      shuffleArray(numbersQuestions);
      numbersAwaitingNext = false;

      if (numbersProgressFill) numbersProgressFill.style.width = "0%";
      if (numbersMedalText) numbersMedalText.textContent = "";
      if (numbersStreakSummary) numbersStreakSummary.textContent = "";
      if (numbersBossText) numbersBossText.textContent = "";
      if (numbersPlayerText) numbersPlayerText.textContent = "";

      showCurrentNumberQuestion();
      return;
    }

    // Mid-round: move on to the next question
    numbersAwaitingNext = false;
    numbersIndex++;
    showCurrentNumberQuestion();
    return;
  }

  // Normal case: checking the current answer (practice / streak)
  const q = numbersQuestions[numbersIndex];
  const guessRaw = numbersAnswerInput ? numbersAnswerInput.value.trim() : "";
  if (!guessRaw) {
    if (numbersFeedback) {
      numbersFeedback.textContent = "Type an answer first.";
      numbersFeedback.className = "feedback bad";
    }
    return;
  }

  // Shared stats
  sessionTotal++;

  const correct = q.answer.trim();
  if (guessRaw === correct) {
    sessionCorrect++;
    sessionStreak++;
    bestSessionStreak = Math.max(bestSessionStreak, sessionStreak);
    sessionXP += 10;

    if (numbersFeedback) {
      numbersFeedback.textContent = "Correct! üéâ";
      numbersFeedback.className = "feedback ok";
    }
  } else {
    sessionStreak = 0;
    if (numbersFeedback) {
      numbersFeedback.textContent = "Almost ‚Äì the answer is " + correct + ".";
      numbersFeedback.className = "feedback bad";
    }
  }

  refreshStatsUI();

  // If this was the last question, go straight to summary
  if (numbersIndex >= numbersQuestions.length - 1) {
    numbersIndex++;
    showCurrentNumberQuestion();
  } else {
    // Otherwise, wait for "Next question"
    numbersAwaitingNext = true;
    if (numbersCheckButtonLabel) {
      numbersCheckButtonLabel.textContent = "Next question";
    }
  }
}
  
async function startNumbersMode() {
  if (numbersFeedback) {
    numbersFeedback.textContent = "";
    numbersFeedback.className = "feedback";
  }
  if (currentQuestionEl) currentQuestionEl.textContent = "Loading‚Ä¶";
  if (numbersProgressText) numbersProgressText.textContent = "";
  if (numbersProgressFill) numbersProgressFill.style.width = "0%";
  if (numbersMedalText) numbersMedalText.textContent = "";
  if (numbersStreakSummary) numbersStreakSummary.textContent = "";
  if (numbersTimerText) numbersTimerText.textContent = "";

  // Stop any existing speed round
  stopSpeedRound(false);

  await loadNumbersFromSheet();

  if (!numbersQuestions.length) {
    if (currentQuestionEl) currentQuestionEl.textContent = "No questions.";
    if (numbersFeedback) {
      numbersFeedback.textContent = "No numbers set. Ask an adult to fill Numbers_Current.";
      numbersFeedback.className = "feedback bad";
    }
    return;
  }

  shuffleArray(numbersQuestions);
  numbersIndex = 0;
  numbersAwaitingNext = false;

  // Reset shared stats
  sessionTotal = 0;
  sessionCorrect = 0;
  sessionStreak = 0;
  bestSessionStreak = 0;
  sessionXP = 0;
  refreshStatsUI();

  updateNumbersModeDescription();

  if (numbersGameMode === "speed") {
    // Prepare for speed round, but do not start timer until first click
    speedRoundActive = false;
    speedTimeRemaining = SPEED_START_SECONDS;
    if (numbersTimerText) {
      numbersTimerText.textContent = `‚è± Ready ‚Äì ${SPEED_START_SECONDS}s`;
    }
    if (numbersCheckButtonLabel) numbersCheckButtonLabel.textContent = "Start speed round";
    if (currentQuestionEl) currentQuestionEl.textContent = "Press start to begin the speed round.";
    if (numbersProgressFill) numbersProgressFill.style.width = "100%";
    return;
  }

  // Practice / streak behaviour
  if (numbersTimerText) numbersTimerText.textContent = "";
  showCurrentNumberQuestion();
}

/* ========== UI ========== */
function initEYFSSelect() {
  if (!eyfsSetSelect) return;
  eyfsSetSelect.innerHTML = "";

  // For now we just have one "current book" that comes from EYFS_Current
  const opt = document.createElement("option");
  opt.value = "current";
  opt.textContent = "Current EYFS book (from sheet)";
  eyfsSetSelect.appendChild(opt);
}

/* Show the right content options for each phase */
phaseSelect.addEventListener("change", () => {
  const phase = phaseSelect.value;

  const robinRadio   = document.querySelector('input[name="contentMode"][value="robin"]');
  const eyfsRadio    = document.querySelector('input[name="contentMode"][value="eyfs"]');
  const numbersRadio = document.querySelector('input[name="contentMode"][value="numbers"]');

  if (phase === "eyfs") {
    // EYFS: only show EYFS option
    if (robinModeOption)  robinModeOption.style.display = "none";
    if (numbersModeOption) numbersModeOption.style.display = "none";
    if (eyfsModeOption)   eyfsModeOption.style.display = "block";

    if (eyfsRadio) eyfsRadio.checked = true;
    currentContentMode = "eyfs";

    if (eyfsSetRow) eyfsSetRow.style.display = "block";
    return;
  }

  if (phase === "y3") {
    // Year 3: show Robin + Numbers, hide EYFS
    if (robinModeOption)  robinModeOption.style.display = "block";
    if (numbersModeOption) numbersModeOption.style.display = "block";
    if (eyfsModeOption)   eyfsModeOption.style.display = "none";

    const current = getRadioValue("contentMode");
    if (current === "eyfs" || !current) {
      if (robinRadio) robinRadio.checked = true;
      currentContentMode = "robin";
    }

    if (eyfsSetRow) eyfsSetRow.style.display = "none";
    return;
  }

  // Default / unknown phase: show Robin + EYFS, hide Numbers
  if (robinModeOption)  robinModeOption.style.display = "block";
  if (eyfsModeOption)   eyfsModeOption.style.display = "block";
  if (numbersModeOption) numbersModeOption.style.display = "none";

  const current = getRadioValue("contentMode");
  if (current === "numbers") {
    if (robinRadio) robinRadio.checked = true;
    currentContentMode = "robin";
  }

  if (eyfsSetRow) {
    eyfsSetRow.style.display = currentContentMode === "eyfs" ? "block" : "none";
  }
});

document.querySelectorAll('input[name="contentMode"]').forEach(radio=>{
  radio.addEventListener("change",()=>{
    currentContentMode = getRadioValue("contentMode") || "robin";
    eyfsSetRow.style.display = currentContentMode === "eyfs" ? "block" : "none";
  });
});
  
modeTabs.forEach(tab=>{
  tab.addEventListener("click",()=>{
    if (tab.classList.contains("disabled")) return;
    const mode = Number(tab.dataset.level);
    currentMode = mode;

    modeTabs.forEach(t=> t.classList.toggle("active", t===tab));

    if (currentTargetWord){
      let disp = currentTargetWord;
      if (currentMode === 2) {
        disp = maskWordForLevel2(currentTargetWord);
      } else if (currentMode === 3) {
        disp = buildClueForLevel3(currentTargetWord);
      }
      currentWordEl.textContent = disp;
      feedbackEl.textContent = "";
      awaitingNextWord = false;
      checkButtonLabel.textContent = "Check";
      toggleSpeakButton();
    } else {
      if (practiceStep.style.display === "block" && currentContentMode !== "numbers") {
        pickNextWord();
      }
    }
  });
});

/* Numbers mode tab switching (Practice / Streak / Speed / Boss) */
if (numbersModeTabs && numbersModeTabs.length) {
  numbersModeTabs.forEach(btn => {
    btn.addEventListener("click", () => {
      const mode = btn.dataset.nmode || "practice";

      // Enforce unlock order
      if (mode === "streak" && !numbersUnlocks.streak) {
        if (numbersFeedback) {
          numbersFeedback.textContent =
            "Finish one full Practice round first to unlock Streak focus.";
          numbersFeedback.className = "feedback bad";
        }
        return;
      }

      if (mode === "speed" && !numbersUnlocks.speed) {
        if (numbersFeedback) {
          numbersFeedback.textContent =
            "Beat a full Streak round first to unlock Speed round.";
          numbersFeedback.className = "feedback bad";
        }
        return;
      }

      if (mode === "boss" && !numbersUnlocks.boss) {
        if (numbersFeedback) {
          numbersFeedback.textContent =
            "Earn at least Bronze in Practice, Streak, and Speed to unlock the Boss battle.";
          numbersFeedback.className = "feedback bad";
        }
        return;
      }

      // Switch mode
      numbersGameMode = mode;

      // Update active tab styling
      numbersModeTabs.forEach(b => {
        b.classList.toggle("active", b === btn);
      });

      // Reset UI for the new mode
      if (numbersStreakSummary) numbersStreakSummary.textContent = "";
      if (numbersMedalText) numbersMedalText.textContent = "";
      if (numbersProgressFill) numbersProgressFill.style.width = "0%";
      if (numbersProgressText) numbersProgressText.textContent = "";
      if (numbersBossText) numbersBossText.textContent = "";
      if (numbersFeedback) {
        numbersFeedback.textContent = "";
        numbersFeedback.className = "feedback";
      }
      if (numbersTimerText) numbersTimerText.textContent = "";

      // Stop any running speed round
      stopSpeedRound(false);

      // Reset shared stats for this run
      sessionTotal = 0;
      sessionCorrect = 0;
      sessionStreak = 0;
      bestSessionStreak = 0;
      sessionXP = 0;
      refreshStatsUI();

      numbersIndex = 0;
      numbersAwaitingNext = false;

      // If we are leaving boss mode, reset boss state + UI
      if (numbersGameMode !== "boss") {
        bossActive = false;
        bossHealth = BOSS_MAX_HEALTH;
        bossQuestionIndex = 0;
        bossCurrentIndex = 0;
        bossCorrect = 0;
        bossAttempts = 0;
        updateBossUI();
      }

      updateNumbersModeDescription();

      if (numbersQuestions && numbersQuestions.length) {
        if (numbersGameMode === "speed") {
          // Prepare speed mode
          speedRoundActive = false;
          speedTimeRemaining = SPEED_START_SECONDS;
          if (numbersTimerText) {
            numbersTimerText.textContent =
              "‚è± Ready ‚Äì " + SPEED_START_SECONDS + "s";
          }
          if (numbersCheckButtonLabel) {
            numbersCheckButtonLabel.textContent = "Start speed round";
          }
          if (currentQuestionEl) {
            currentQuestionEl.textContent =
              "Press start to begin the speed round.";
          }
          if (numbersProgressFill) numbersProgressFill.style.width = "100%";
        } else if (numbersGameMode === "boss") {
          // Prepare boss mode
          resetBossState();        // this calls updateBossUI() too
          if (numbersBossGraphic) {
          numbersBossGraphic.classList.remove("numbers-boss-taunt");
        }
          bossActive = false;      // battle not started until first click
          if (currentQuestionEl) {
            currentQuestionEl.textContent = "Press start to challenge the boss.";
          }
          if (numbersCheckButtonLabel) {
            numbersCheckButtonLabel.textContent = "Start battle";
          }
        } else {
          // Practice / streak
          showCurrentNumberQuestion();
        }
      }
    });
  });
}

startPracticeBtn.addEventListener("click",()=>{
  const nameRaw = learnerNameInput.value || "";
  const name = nameRaw.trim();
  const phase = phaseSelect.value;

  // Secret parent unlock code: type it into the name box
  const SECRET_UNLOCK = "grownups-only"; // change if you like
  if (name.toLowerCase() === SECRET_UNLOCK) {
    parentTestUnlockActive = true;

    if (typeof parentUnlockAll === "function") {
      parentUnlockAll();
    } else {
      console.warn("[UNLOCK] parentUnlockAll() is missing ‚Äì did you add the function?");
    }

    learnerNameInput.value = "";
    alert("Unlocked for testing. Now type the child‚Äôs name and start as normal.");
    return;
  }

  if (!name){ alert("Enter a name."); return; }
  if (!phase){ alert("Choose a year/phase."); return; }

  currentLearner = name;
  currentPhase = phase;
  currentContentMode = getRadioValue("contentMode") || "robin";

  // Reset session stats
  sessionTotal = 0;
  sessionCorrect = 0;
  sessionStreak = 0;
  bestSessionStreak = 0;
  sessionXP = 0;
  refreshStatsUI();

  // Reset level progression
  levelCompletion = { 1:false, 2:false, 3:false };
  levelWordSets = {
    1: new Set(),
    2: new Set(),
    3: new Set()
  };
  updateLevelTabsUI();
  updateWordsearchLockUI();

  identityStep.style.display = "none";
  practiceStep.style.display = "block";

  if (currentContentMode === "numbers") {
    if (spellingsCard) spellingsCard.style.display = "none";
    if (numbersCard) numbersCard.style.display = "block";
    if (wordsearchStep) wordsearchStep.style.display = "none";

    subtitle.style.display = "none";
    modeLabel.innerHTML = `<strong>Numbers practice</strong> ‚Äì practising with ${name}.`;

    if (numbersTitle) numbersTitle.textContent = `Numbers practice: ${name}`;
    if (numbersListLabel) numbersListLabel.textContent = "Using this week‚Äôs numbers.";

    startNumbersMode();
    return;
  }

  // Spellings (Robin / EYFS)
  if (spellingsCard) spellingsCard.style.display = "block";
  if (numbersCard) numbersCard.style.display = "none";
  if (wordsearchStep) wordsearchStep.style.display = "block";

  activeLearnerTitle.textContent = `Practising: ${name}`;
  subtitle.style.display = "none";
  modeLabel.innerHTML = `<strong>Spellings practice</strong> ‚Äì practising with ${name}.`;

if (currentContentMode === "robin"){
  listLabel.textContent = "Using this week‚Äôs spellings list.";
} else {
  listLabel.textContent = "EYFS blending ‚Äì current book from sheet.";
}

  rebuildWordQueue();
  pickNextWord();

    // If parent testing unlock is active, re-apply after the normal start resets
  if (parentTestUnlockActive && typeof parentUnlockAll === "function") {
    parentUnlockAll();
  }
});

eyfsSetSelect.addEventListener("change", () => {
  if (practiceStep.style.display === "block" && currentContentMode === "eyfs") {
    listLabel.textContent = "EYFS blending ‚Äì current book from sheet.";
    rebuildWordQueue();
    pickNextWord();
  }
});

checkButton.addEventListener("click", handleAnswer);
answerInput.addEventListener("keydown", e=>{
  if (e.key==="Enter"){
    e.preventDefault();
    handleAnswer();
  }
});

function goBackToIdentity() {
  practiceStep.style.display = "none";
  wordsearchStep.style.display = "none";
  identityStep.style.display = "flex";

  if (spellingsCard) spellingsCard.style.display = "block";
  if (numbersCard) numbersCard.style.display = "none";

  modeLabel.innerHTML = "<strong>Spellings practice</strong>";
  subtitle.style.display = "block";
  subtitle.textContent = "Who‚Äôs practising? Enter your name and year to begin.";
}

if (changeLearnerLink) {
  changeLearnerLink.addEventListener("click", goBackToIdentity);
}
if (numbersChangeLearnerLink) {
  numbersChangeLearnerLink.addEventListener("click", goBackToIdentity);
}

if (speakButton) {
  speakButton.addEventListener("click", speakCurrentWord);
}

if (extraClueButton) {
  extraClueButton.addEventListener("click", () => {
    if (!currentTargetWord) return;
    currentWordEl.textContent = buildPatternForLevel3(currentTargetWord);
  });
}

/* Numbers button wiring */
if (numbersCheckButton) {
  numbersCheckButton.addEventListener("click", handleNumbersAnswer);
}
if (numbersAnswerInput) {
  numbersAnswerInput.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleNumbersAnswer();
    }
  });
}

/* ===== Wordsearch logic ===== */
function clearDragSelection() {
  if (!wordsearchGridEl) return;
  const selectedCells = wordsearchGridEl.querySelectorAll('.ws-cell.ws-selected');
  selectedCells.forEach(cell => cell.classList.remove('ws-selected'));
  selectionCells = [];
}

function fireWordsearchCelebration() {
  if (typeof confetti === "function") {
    confetti({
      particleCount: 200,
      spread: 80,
      origin: { y: 0.6 }
    });
  }
}

function markWordFound(wordIndex, cells) {
  if (wordsearchFound.has(wordIndex)) return;
  wordsearchFound.add(wordIndex);

  const colour = wordsearchColours[wordIndex % wordsearchColours.length];
  cells.forEach(cell => {
    cell.classList.remove('ws-selected');
    cell.style.backgroundColor = colour;
    cell.style.color = '#111';
  });

  const span = wordsearchWordsEl.querySelector(`.ws-word[data-index="${wordIndex}"]`);
  if (span) span.classList.add('found');

  if (wordsearchFound.size === wordsearchCurrentWords.length && wordsearchCurrentWords.length > 0) {
    fireWordsearchCelebration();
  }
}

function generateWordsearch() {
  const wordsRaw = getWordList()
    .map(w => String(w || "").trim().toLowerCase())
    .filter(w => w.length > 0);

  if (!wordsRaw.length) {
    wordsearchGridEl.innerHTML = "<p>No words available for word search.</p>";
    wordsearchWordsEl.textContent = "";
    wordsearchCurrentWords = [];
    return;
  }

  // Shuffle so we don't always get the same first N words
  const pool = shuffleArray(wordsRaw.slice());

  // Decide grid size based on longest word, with a sensible cap
  const MIN_GRID_SIZE = 10;
  const MAX_GRID_SIZE = 12;

  let longest = 0;
  for (const w of pool) {
    if (w.length > longest) longest = w.length;
  }

  // If some words are longer than our hard cap, drop them from the wordsearch pool
  let usable = pool;
  if (longest > MAX_GRID_SIZE) {
    usable = pool.filter(w => w.length <= MAX_GRID_SIZE);
  }

  if (!usable.length) {
    wordsearchGridEl.innerHTML =
      "<p>These words are too long for the current word search grid.</p>";
    wordsearchWordsEl.textContent = "";
    wordsearchCurrentWords = [];
    return;
  }

  // Recompute longest among usable words and set grid size
  longest = 0;
  for (const w of usable) {
    if (w.length > longest) longest = w.length;
  }
  const size = Math.max(MIN_GRID_SIZE, longest);

  // Allow more words for EYFS (shorter words), keep 6 for Robin
  const maxWords = (currentContentMode === "eyfs") ? 12 : 6;
  const selected = usable.slice(0, Math.min(maxWords, usable.length));

  if (!selected.length) {
    wordsearchGridEl.innerHTML = "<p>No suitable words for word search.</p>";
    wordsearchWordsEl.textContent = "";
    wordsearchCurrentWords = [];
    return;
  }

  const directions = [
    [0, 1],  // right
    [1, 0]   // down
  ];

  function tryBuildGrid() {
    const grid = Array.from({ length: size }, () => Array(size).fill(null));

    for (const word of selected) {
      if (word.length > size) {
        return null;
      }

      let placed = false;
      for (let attempts = 0; attempts < 100 && !placed; attempts++) {
        const [dr, dc] = directions[Math.floor(Math.random() * directions.length)];

        const maxRow = dr === 0 ? size - 1 : size - word.length;
        const maxCol = dc === 0 ? size - word.length : size - 1;
        const row = Math.floor(Math.random() * (maxRow + 1));
        const col = Math.floor(Math.random() * (maxCol + 1));

        let ok = true;
        for (let i = 0; i < word.length; i++) {
          const r = row + dr * i;
          const c = col + dc * i;
          const cell = grid[r][c];
          if (cell !== null && cell !== word[i]) {
            ok = false;
            break;
          }
        }
        if (!ok) continue;

        for (let i = 0; i < word.length; i++) {
          const r = row + dr * i;
          const c = col + dc * i;
          grid[r][c] = word[i];
        }
        placed = true;
      }

      if (!placed) {
        return null;
      }
    }

    return grid;
  }

  let grid = null;
  for (let attempt = 0; attempt < 40 && !grid; attempt++) {
    grid = tryBuildGrid();
  }
  if (!grid) {
    wordsearchGridEl.innerHTML = "<p>Could not place all words. Try again.</p>";
    wordsearchWordsEl.textContent = "";
    wordsearchCurrentWords = [];
    return;
  }

  // Fill empty cells with random letters
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      if (!grid[r][c]) {
        const letter = String.fromCharCode(97 + Math.floor(Math.random() * 26));
        grid[r][c] = letter;
      }
    }
  }

  wordsearchCurrentWords = selected.slice();
  wordsearchFound = new Set();

  const table = document.createElement('table');
  table.className = 'ws-table';
  for (let r = 0; r < size; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < size; c++) {
      const td = document.createElement('td');
      td.textContent = grid[r][c].toUpperCase();
      td.classList.add('ws-cell');
      td.dataset.r = String(r);
      td.dataset.c = String(c);
      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
  wordsearchGridEl.innerHTML = '';
  wordsearchGridEl.appendChild(table);

  wordsearchWordsEl.innerHTML = '';
  wordsearchCurrentWords.forEach((w, idx) => {
    const span = document.createElement('span');
    span.className = 'ws-word';
    span.dataset.index = String(idx);
    span.textContent = w.toUpperCase();
    wordsearchWordsEl.appendChild(span);
  });
}

if (generateWordsearchBtn) {
  generateWordsearchBtn.addEventListener("click", generateWordsearch);
}

/* Wordsearch drag logic (mouse + touch) */
function getCellFromEvent(e) {
  if (e.touches && e.touches.length) {
    const t = e.touches[0];
    const el = document.elementFromPoint(t.clientX, t.clientY);
    if (!el) return null;
    return el.closest('.ws-cell');
  } else if (e.changedTouches && e.changedTouches.length) {
    const t = e.changedTouches[0];
    const el = document.elementFromPoint(t.clientX, t.clientY);
    if (!el) return null;
    return el.closest('.ws-cell');
  } else {
    return e.target.closest('.ws-cell');
  }
}

function updateSelectionToCell(cell) {
  clearDragSelection();
  if (!cell) return;

  const row = parseInt(cell.dataset.r, 10);
  const col = parseInt(cell.dataset.c, 10);

  if (dragStartRow === null || dragStartCol === null) {
    dragStartRow = row;
    dragStartCol = col;
  }

  const currR = row;
  const currC = col;

  if (dragStartRow === currR) {
    const minC = Math.min(dragStartCol, currC);
    const maxC = Math.max(dragStartCol, currC);
    for (let c = minC; c <= maxC; c++) {
      const el = wordsearchGridEl.querySelector(`.ws-cell[data-r="${dragStartRow}"][data-c="${c}"]`);
      if (el) {
        el.classList.add('ws-selected');
        selectionCells.push(el);
      }
    }
  } else if (dragStartCol === currC) {
    const minR = Math.min(dragStartRow, currR);
    const maxR = Math.max(dragStartRow, currR);
    for (let r = minR; r <= maxR; r++) {
      const el = wordsearchGridEl.querySelector(`.ws-cell[data-r="${r}"][data-c="${dragStartCol}"]`);
      if (el) {
        el.classList.add('ws-selected');
        selectionCells.push(el);
      }
    }
  }
}

function handleWordsearchDown(e) {
  const cell = getCellFromEvent(e);
  if (!cell) return;
  if (e.cancelable) e.preventDefault();

  selecting = true;
  dragStartRow = parseInt(cell.dataset.r, 10);
  dragStartCol = parseInt(cell.dataset.c, 10);
  updateSelectionToCell(cell);
}

function handleWordsearchMove(e) {
  if (!selecting) return;
  const cell = getCellFromEvent(e);
  if (!cell) return;
  if (e.cancelable) e.preventDefault();
  updateSelectionToCell(cell);
}

function handleWordsearchUp(e) {
  if (!selecting) return;
  selecting = false;

  if (!selectionCells.length) {
    clearDragSelection();
    dragStartRow = dragStartCol = null;
    return;
  }

  const letters = selectionCells.map(cell => cell.textContent.toLowerCase());
  const str = letters.join("");
  const rev = letters.slice().reverse().join("");

  let matchedIndex = -1;
  for (let i = 0; i < wordsearchCurrentWords.length; i++) {
    const w = wordsearchCurrentWords[i];
    if (w === str || w === rev) {
      matchedIndex = i;
      break;
    }
  }

  if (matchedIndex >= 0) {
    markWordFound(matchedIndex, selectionCells);
  } else {
    clearDragSelection();
  }

  dragStartRow = dragStartCol = null;
}

if (wordsearchGridEl) {
  wordsearchGridEl.addEventListener('mousedown', handleWordsearchDown);
  wordsearchGridEl.addEventListener('mousemove', handleWordsearchMove);
  document.addEventListener('mouseup', handleWordsearchUp);

  wordsearchGridEl.addEventListener('touchstart', handleWordsearchDown, { passive: false });
  wordsearchGridEl.addEventListener('touchmove', handleWordsearchMove, { passive: false });
  document.addEventListener('touchend', handleWordsearchUp);
  document.addEventListener('touchcancel', handleWordsearchUp);
}

window.addEventListener("load", () => {
  setInitialTheme();
  initEYFSSelect();
  loadRobinWordsFromSheet();
  loadEyfsWordsFromSheet();
  updateLevelTabsUI();
  updateWordsearchLockUI();
  updateNumbersModeDescription();
  updateNumbersModeLocks();
});
</script>
</body>
</html>
